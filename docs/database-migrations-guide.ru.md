# Руководство по миграциям базы данных

Этот документ объясняет, как правильно вносить изменения в структуру базы данных в приложении Tactris с использованием системы миграций.

## Обзор

Приложение Tactris использует подход на основе миграций для управления изменениями схемы базы данных. Это гарантирует, что:

- Изменения схемы версионируются и отслеживаются
- Изменения могут быть применены последовательно в разных средах
- Откаты возможны при необходимости
- Несколько разработчиков могут вносить изменения схемы без конфликтов

## Текущий подход против рекомендуемого подхода

### ❌ Текущий подход (Не рекомендуется)
Прямое изменение файла `schema.sql` и использование его для пересоздания базы данных:
- Может привести к потере данных в продакшене
- Нет отслеживания, когда изменения были применены
- Сложно координировать изменения в разных средах
- Риск применения изменений в неправильном порядке

### ✅ Рекомендуемый подход (Использование миграций)
Использование системы миграций:
- Отслеживает, какие изменения были применены
- Гарантирует, что изменения применяются в правильном порядке
- Сохраняет целостность данных во время изменений схемы
- Работает последовательно в средах разработки, тестирования и продакшена

## Как вносить изменения в базу данных

### 1. Планирование изменения схемы

Перед внесением каких-либо изменений, подумайте:

- Какие таблицы/столбцы нужно добавить, изменить или удалить?
- Повлияют ли эти изменения на существующие данные?
- Нужно ли мигрировать существующие данные?
- Каковы зависимости между таблицами?
- Как вы будете обрабатывать изменения в коде приложения?

### 2. Создание нового файла миграции

Создайте новый SQL-файл в каталоге `migrations/` с соглашением об именовании:
```
YYYYMMDDHHMMSS_описание.sql
```

Например:
- `20251128143000_add_user_last_login.sql`
- `20251129091500_modify_game_session_constraints.sql`

### 3. Написание SQL-запроса миграции

Ваш файл миграции должен содержать:

```sql
-- Миграция для добавления столбца last_login в таблицу users
-- Описание: Добавляет временной столбец last_login для отслеживания активности пользователя

-- Добавление нового столбца
ALTER TABLE users ADD COLUMN last_login TIMESTAMP WITH TIME ZONE;

-- Обновление столбца для существующих пользователей (опционально)
UPDATE users SET last_login = created_at WHERE last_login IS NULL;

-- Сделать столбец NOT NULL при необходимости
ALTER TABLE users ALTER COLUMN last_login SET NOT NULL;

-- Добавить комментарий для документации
COMMENT ON COLUMN users.last_login IS 'Временная метка последнего входа пользователя';

-- Записать эту миграцию как примененную (обязательно)
INSERT INTO migrations (name) VALUES ('20251128143000_add_user_last_login.sql');
```

### 4. Рассмотрение рекомендаций по миграции

При написании миграций следуйте этим рекомендациям:

#### Для добавления столбцов:
```sql
-- Безопасно: Добавить со значением по умолчанию
ALTER TABLE table_name ADD COLUMN new_column TEXT DEFAULT 'default_value';

-- Безопасно: Добавить как nullable, затем обновить значения, затем сделать NOT NULL
ALTER TABLE table_name ADD COLUMN new_column TEXT;
UPDATE table_name SET new_column = 'some_value' WHERE condition;
ALTER TABLE table_name ALTER COLUMN new_column SET NOT NULL;
```

#### Для удаления столбцов:
```sql
-- Сначала удалить все ссылки в коде приложения
-- Затем удалить столбец
ALTER TABLE table_name DROP COLUMN old_column;
```

#### Для изменения столбцов:
```sql
-- Изменение типа данных
ALTER TABLE table_name ALTER COLUMN column_name TYPE new_type;

-- Добавление ограничений
ALTER TABLE table_name ADD CONSTRAINT constraint_name CHECK (condition);

-- Удаление ограничений
ALTER TABLE table_name DROP CONSTRAINT constraint_name;
```

#### Для добавления таблиц:
```sql
CREATE TABLE new_table (
    id uuid DEFAULT uuid_generate_v4() PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Добавить комментарии для документации
COMMENT ON TABLE new_table IS 'Описание новой таблицы';
```

### 5. Тестирование миграции

Перед применением в продакшен:

1. Протестировать на базе данных разработки с образцом данных
2. Убедиться, что миграция может быть применена без ошибок
3. Проверить, что функциональность приложения по-прежнему работает
4. Если возможно, протестировать процесс отката

### 6. Применение миграции

Запустите миграцию с помощью командной строки:

```bash
npm run migrate
```

Это применит все ожидающие миграции в хронологическом порядке.

## Структура файла миграции

Каждый файл миграции должен следовать этой структуре:

```sql
-- Краткое описание того, что делает миграция
-- Описание: Полное описание вносимых изменений

-- Ваши SQL-операторы здесь
-- Добавить, изменить или удалить объекты базы данных

-- Обновить таблицу миграций (обязательно)
INSERT INTO migrations (name) VALUES ('YYYYMMDDHHMMSS_описание.sql');
```

## Обработка миграции данных

Если ваше изменение схемы требует преобразования существующих данных:

```sql
-- Пример: Миграция данных из одного формата в другой
-- Добавить временный столбец
ALTER TABLE users ADD COLUMN temp_preferences JSONB;

-- Мигрировать данные из старого формата в новый
UPDATE users 
SET temp_preferences = 
    jsonb_build_object(
        'theme', old_theme,
        'sound', old_sound_enabled
    )
WHERE old_theme IS NOT NULL OR old_sound_enabled IS NOT NULL;

-- Удалить старые столбцы
ALTER TABLE users DROP COLUMN old_theme;
ALTER TABLE users DROP COLUMN old_sound_enabled;

-- Переименовать временный столбец в окончательное имя
ALTER TABLE users RENAME COLUMN temp_preferences TO preferences;
```

## Стратегия отката

Для продакшен-систем подумайте, как откатить изменения при необходимости:

1. **Простые структурные изменения**: Часто можно создать обратную миграцию
2. **Изменения данных**: Делать резервные копии перед применением миграций
3. **Сложные изменения**: Тестировать процесс отката в разработке сначала

Текущий скрипт отката удаляет запись миграции, но для продакшена вы можете захотеть реализовать конкретную логику отката.

## Назначение файла Schema.sql

Файл `schema.sql` служит справочником для текущей структуры базы данных и полезен для:

- Настройки нового экземпляра базы данных
- Понимания полной схемы в определенный момент времени
- Первоначальной настройки базы данных в разработке

**Важно**: Не используйте `schema.sql` напрямую для внесения изменений схемы в развернутых средах. Всегда используйте миграции.

## Соображения, специфичные для среды

- **Разработка**: Миграции можно применять свободно, и базу данных можно сбросить
- **Тестирование**: Миграции должны максимально точно отражать продакшен
- **Продакшен**: 
  - Всегда создавать резервную копию перед запуском миграций
  - Тестировать миграции на копии продакшен-данных сначала
  - Планировать миграции в периоды с низким трафиком
  - Иметь план отката под рукой

## Устранение распространенных проблем

### Ошибка "Миграция уже применена"
Если миграция частично не удалась, система транзакций должна обрабатывать откаты. Если нет, вам может понадобиться вручную исправить состояние базы данных и запись миграции.

### Зависимости между таблицами
При добавлении внешних ключей убедитесь, что ссылочная таблица существует. Порядок применения миграций должен быть соответствующим.

### Соображения производительности
Для больших таблиц подумайте:
- Добавление индексов в часы с низкой нагрузкой
- Разбиение больших обновлений данных на более мелкие фрагменты
- Использование `CONCURRENTLY` для создания индексов (специфично для PostgreSQL)

## Пример: Добавление новой функции с изменениями базы данных

Допустим, вы хотите добавить функцию "список друзей":

1. Создать файл миграции: `migrations/20251128150000_add_friendships_table.sql`
2. Написать миграцию:
```sql
-- Добавить таблицу дружбы для функции списка друзей
CREATE TABLE friendships (
    id uuid DEFAULT uuid_generate_v4() PRIMARY KEY,
    user_id uuid NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    friend_id uuid NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    status VARCHAR(20) DEFAULT 'pending' NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE(user_id, friend_id)
);

-- Добавить триггер updated_at
CREATE TRIGGER update_friendships_updated_at 
    BEFORE UPDATE ON friendships 
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- Добавить комментарии
COMMENT ON TABLE friendships IS 'Отношения дружбы пользователя';
COMMENT ON COLUMN friendships.status IS 'Статус дружбы: pending, accepted, blocked';

-- Записать миграцию
INSERT INTO migrations (name) VALUES ('20251128150000_add_friendships_table.sql');
```

3. Обновить код вашего приложения для использования новой таблицы
4. Протестировать изменения
5. Развернуть с миграцией

## Заключение

Использование системы миграций гарантирует, что изменения схемы базы данных безопасны, отслеживаемы и воспроизводимы в разных средах. Всегда помните:
- Тщательно тестировать миграции перед применением в продакшен
- Держать миграции небольшими и сфокусированными
- Учитывать влияние на существующие данные
- Иметь план отката
- Обновлять код приложения для работы с новой схемой